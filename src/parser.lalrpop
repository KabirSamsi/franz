use std::str::*;
use crate::ast::{Expr, KeySigPitch, NoteLen, BasePitch, RhythmComp, PitchComp, Accidental, BaseNoteLen, AExp, BExp, Tempo, Param};

grammar;

pub Pitches: Expr = {
    <p: PitchesDecl> <name: Handle> "=" "{" <comp: PitchComp> "};" => Expr::PitchAssgn(name, Box::new(Expr::Pitches(comp)))
};

pub Motif : Expr = {
    <m: MotifDecl> <name: Handle> "(" <params: Comma<Handle>> ")" "=" "{" <comp: RhythmComp> "};" => Expr::MotifAssgn(name, Box::new(Expr::Motif(params, comp)))
};

pub PitchComp : PitchComp = {
    <p1:PitchComp> ";" <p2:PitchCompLevel2> => PitchComp::Plus(Box::new(p1), Box::new(p2)),
    PitchCompLevel2
};

PitchCompLevel2 : PitchComp = {
    <n: ATerminal> "*" <p:PitchCompLevel3> => PitchComp::Times(n, Box::new(p)),
    PitchCompLevel3
};

PitchCompLevel3 : PitchComp = {
    <p: PitchTerminal> => p,
    "{" <p: PitchComp> "}" => p
};

PitchTerminal : PitchComp = {
    <note:NoteName> <n:ATerminal> => PitchComp::Pitch((note, Accidental::Blank, n)),
    <note:NoteName> <n:ATerminal> "_" <acc:Accidental> => PitchComp::Pitch((note, acc, n))
};

pub RhythmComp: RhythmComp = {
    <r1:RhythmComp> ";" <r2:RhythmCompLevel2> => RhythmComp::Plus(Box::new(r1), Box::new(r2)),
    RhythmCompLevel2,
};

RhythmCompLevel2: RhythmComp = {
    <b:BExp> "?" <r1:RhythmCompLevel3> ":" <r2:RhythmCompLevel3> => RhythmComp::Ternary(b, Box::new(r1), Box::new(r2)),
    RhythmCompLevel3,
};

RhythmCompLevel3: RhythmComp = {
    <n:ATerminal> "*" <r:RhythmCompLevel4> => RhythmComp::Times(n, Box::new(r)),
    RhythmCompLevel4,
};

RhythmCompLevel4: RhythmComp = {
    <r:RhythmTerminal> => r,
    "{" <r:RhythmComp> "}" => r
};

RhythmTerminal: RhythmComp = {
    <b: NoteLen> => RhythmComp::Beat(b)
};

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Param : Param = {
    <k: KeyDecl> "=" "{" <pitches: Comma<KeySigPitch>> "};" => Param::KeySig(pitches),
    <m: MeterDecl> "=" <n1:AExp> "/" <n2:AExp> ";" => Param::TimeSig((n1, n2)),
    <t: TempoDecl> "=" <tempo:Tempo> ";" => Param::Tempo(tempo)
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

KeySigPitch: KeySigPitch = {
    <note: NoteName> "_" <acc: Accidental> => (note, acc)
};

NoteLen: NoteLen = {
    #[precedence(level="1")]
    <b:BaseNoteLen> <dots:r"[.]*"> => (b, ((String::from(dots).chars().count())).try_into().unwrap()),

    #[precedence(level="0")]
    <b:BaseNoteLen> => (b, 0)
};

pub BExp: BExp = {
    <e1:BExp> "||" <e2:BExpLevel1> => BExp::Or(Box::new(e1), Box::new(e2)),
    BExpLevel1
};

BExpLevel1: BExp = {
    <e1:BExpLevel1> "&&" <e2:BExpLevel2> => BExp::And(Box::new(e1), Box::new(e2)),
    BExpLevel2
};

BExpLevel2 : BExp = {
    "!" <e:BExpLevel2> => BExp::Not(Box::new(e)),
    BExpLevel3
};

BExpLevel3 : BExp = {
    <b: BTerminal> => b,
    "(" <e : BExp> ")" => e
};

BTerminal : BExp = {
    <t: True> => BExp::True,
    <f: False> => BExp::False,
};

pub AExp: AExp = {
    <e1:AExp> "+" <e2:AExpLevel1> => AExp::Plus(Box::new(e1), Box::new(e2)),
    AExpLevel1,
};

AExpLevel1: AExp = {
    <e1:AExpLevel1> "*" <e2:AExpLevel2> => AExp::Times(Box::new(e1), Box::new(e2)),
    AExpLevel2,
};

AExpLevel2: AExp = {
    <n:ATerminal> => n,
    "(" <e:AExp> ")" => e,
};

ATerminal: AExp = {
    r"[0-9]+" => AExp::Int(i32::from_str(<>).unwrap()),
};

Handle : String = {
    r"[a-z]+[a-zA-Z]*" => (*<>).to_string()
};

NoteName: BasePitch = {
    "c" => BasePitch::C,
    "d" => BasePitch::D,
    "e" => BasePitch::E,
    "f" => BasePitch::F,
    "g" => BasePitch::G,
    "a" => BasePitch::A,
    "b" => BasePitch::B,
    "rst" => BasePitch::Rest,
};

BaseNoteLen: BaseNoteLen = {
    "ts" => BaseNoteLen::Ts,
    "sx" => BaseNoteLen::Sixteenth,
    "et" => BaseNoteLen::Eighth,
    "qt" => BaseNoteLen::Qtr,
    "hf" => BaseNoteLen::Half,
    "wh" => BaseNoteLen::Whole
};

Accidental: Accidental = {
    "flt" => Accidental::Flat,
    "shp" => Accidental::Sharp,
    "ntl" => Accidental::Natural,
};

pub Tempo: Tempo = {
    "Presto" => Tempo::Presto,
    "Allegro" => Tempo::Allegro,
    "Andante" => Tempo::Andante,
    "Adagio" => Tempo::Adagio,
    "Lento" => Tempo::Lento
};

MotifDecl : String = {
    "motif" => (*"motif").to_string()
};

PitchesDecl : String = {
    "pitches" => (*"pitches").to_string()
};

PhraseDecl : String = {
    "phrase" => (*"phrase").to_string()
};

KeyDecl : String = {
    "key" => (*"key").to_string()
};

MeterDecl : String = {
    "meter" => (*"meter").to_string()
};

TempoDecl : String = {
    "tempo" => (*"tempo").to_string()
};

True : bool = {
    "true" => true
};

False: bool = { 
    "false" => false
};